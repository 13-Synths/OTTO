<?xml version='1.0' encoding='utf-8'?>
<class abstract="true" id="top1::TapeBuffer" name="TapeBuffer" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
A Wrapper for ringbuffers, used for the tapemodule.
</doc>
  <class name="CompareTapeSlice" ref="top1::TapeBuffer::CompareTapeSlice#top1::TapeBuffer::CompareTapeSlice" />
  <struct name="RingBuffer" ref="top1::TapeBuffer::RingBuffer#top1::TapeBuffer::RingBuffer" />
  <class name="TapeSliceSet" ref="top1::TapeBuffer::TapeSliceSet#top1::TapeBuffer::TapeSliceSet" />
  <field id="top1::TapeBuffer::buffer" name="buffer">
    <type name="RingBuffer" ref="top1::TapeBuffer::RingBuffer#top1::TapeBuffer::RingBuffer" />
  </field>
  <field id="top1::TapeBuffer::trackSlices" name="trackSlices">
    <type class="array" size="4">
      <type name="TapeSliceSet" ref="top1::TapeBuffer::TapeSliceSet#top1::TapeBuffer::TapeSliceSet" />
    </type>
  </field>
  <constructor abstract="yes" id="top1::TapeBuffer::TapeBuffer" name="TapeBuffer" />
  <constructor abstract="yes" id="top1::TapeBuffer::TapeBuffer" name="TapeBuffer">
    <argument id="top1::TapeBuffer::TapeBuffer::" name="">
      <type name="TapeBuffer" qualifier=" &amp;" ref="top1::TapeBuffer#top1::TapeBuffer" />
    </argument>
  </constructor>
  <constructor abstract="yes" id="top1::TapeBuffer::TapeBuffer" name="TapeBuffer">
    <argument id="top1::TapeBuffer::TapeBuffer::" name="">
      <type name="TapeBuffer &amp;&amp;" />
    </argument>
  </constructor>
  <destructor abstract="yes" id="top1::TapeBuffer::~TapeBuffer" name="~TapeBuffer" />
  <method abstract="yes" id="top1::TapeBuffer::drop" name="drop">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::TapeBuffer::drop::track" name="track">
      <type name="Track" ref="top1::Track#top1::Track" />
    </argument>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::exit" name="exit">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::goTo" name="goTo">
    <doc>
Jumps to another position in the tape
@tapePos position to jump to
</doc>
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::TapeBuffer::goTo::tapePos" name="tapePos">
      <doc>position to jump to</doc>
      <type name="TapeTime" />
    </argument>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::init" name="init">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::lift" name="lift">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::TapeBuffer::lift::track" name="track">
      <type name="Track" ref="top1::Track#top1::Track" />
    </argument>
  </method>
  <method id="top1::TapeBuffer::position" name="position">
    <undocumented-return />
    <return>
      <type name="TapeTime" />
    </return>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::readBW" name="readBW">
    <doc>
Reads backwards along the tape, moving the playPoint.
@param nframes number of frames to read.
@return a vector of length nframes with the data. The data will be in the
       read order, meaning reverse.
</doc>
    <undocumented-return />
    <return>
      <doc>a vector of length nframes with the data. The data will be in the
       read order, meaning reverse.</doc>
      <type name="std::vector&lt;top1::audio::AudioFrame&lt;4, float&gt;, std::allocator&lt;top1::audio::AudioFrame&lt;4, float&gt; &gt; &gt;" />
    </return>
    <argument id="top1::TapeBuffer::readBW::nframes" name="nframes">
      <type name="uint" />
    </argument>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::readFW" name="readFW">
    <doc>
Reads forwards along the tape, moving the playPoint.
@param nframes number of frames to read.
@return a vector of length nframes with the data.
</doc>
    <undocumented-return />
    <return>
      <doc>a vector of length nframes with the data.</doc>
      <type name="std::vector&lt;top1::audio::AudioFrame&lt;4, float&gt;, std::allocator&lt;top1::audio::AudioFrame&lt;4, float&gt; &gt; &gt;" />
    </return>
    <argument id="top1::TapeBuffer::readFW::nframes" name="nframes">
      <type name="uint" />
    </argument>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::timeStr" name="timeStr">
    <undocumented-return />
    <return>
      <type name="std::string" />
    </return>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::writeBW" name="writeBW">
    <doc>
Write data to the tape.
@param data the data to write. Will be written in reverse order.
@param offset the end of the data will be at playPoint + offset
@param writeFunc the function used to write the data. Run for each frame,
  recieves the original and the new data as arguments.
@return the amount of unwritten frames
</doc>
    <undocumented-return />
    <return>
      <doc>the amount of unwritten frames</doc>
      <type name="uint" />
    </return>
    <argument id="top1::TapeBuffer::writeBW::data" name="data">
      <type name="std::vector&lt;top1::audio::AudioFrame&lt;4, float&gt;, std::allocator&lt;top1::audio::AudioFrame&lt;4, float&gt; &gt; &gt;" />
    </argument>
    <argument id="top1::TapeBuffer::writeBW::offset" name="offset">
      <type name="uint" />
    </argument>
    <argument id="top1::TapeBuffer::writeBW::writeFunc" name="writeFunc">
      <type name="std::function&lt;top1::audio::AudioFrame&lt;4, float&gt; (top1::audio::AudioFrame&lt;4, float&gt;, top1::audio::AudioFrame&lt;4, float&gt;)&gt;" />
    </argument>
  </method>
  <method abstract="yes" id="top1::TapeBuffer::writeFW" name="writeFW">
    <doc>
Write data to the tape.
@param data the data to write.
@param offset the end of the data will be at playPoint - offset
@param writeFunc the function used to write the data. Run for each frame,
  recieves the original and the new data as arguments.
@return the amount of unwritten frames
</doc>
    <undocumented-return />
    <return>
      <doc>the amount of unwritten frames</doc>
      <type name="uint" />
    </return>
    <argument id="top1::TapeBuffer::writeFW::data" name="data">
      <type name="std::vector&lt;top1::audio::AudioFrame&lt;4, float&gt;, std::allocator&lt;top1::audio::AudioFrame&lt;4, float&gt; &gt; &gt;" />
    </argument>
    <argument id="top1::TapeBuffer::writeFW::offset" name="offset">
      <type name="uint" />
    </argument>
    <argument id="top1::TapeBuffer::writeFW::writeFunc" name="writeFunc">
      <type name="std::function&lt;top1::audio::AudioFrame&lt;4, float&gt; (top1::audio::AudioFrame&lt;4, float&gt;, top1::audio::AudioFrame&lt;4, float&gt;)&gt;" />
    </argument>
  </method>
  <struct access="protected" anonymous="yes" id="top1::TapeBuffer::(anonymous::1)" name="(anonymous::1)">
    <field id="top1::TapeBuffer::data" name="data">
      <type name="std::vector&lt;float, std::allocator&lt;float&gt; &gt;" />
    </field>
    <field id="top1::TapeBuffer::fromTrack" name="fromTrack">
      <type name="Track" ref="top1::Track#top1::Track" />
    </field>
    <field id="top1::TapeBuffer::fromSlice" name="fromSlice">
      <type name="TapeSlice" />
    </field>
    <field id="top1::TapeBuffer::toTrack" name="toTrack">
      <type name="Track" ref="top1::Track#top1::Track" />
    </field>
    <field id="top1::TapeBuffer::toTime" name="toTime">
      <type name="TapeTime" />
    </field>
    <field id="top1::TapeBuffer::lock" name="lock">
      <type name="std::mutex" />
    </field>
    <field id="top1::TapeBuffer::done" name="done">
      <type name="std::condition_variable" />
    </field>
  </struct>
  <field access="protected" id="top1::TapeBuffer::diskThread" name="diskThread">
    <type name="std::unique_ptr&lt;top1::TapeDiskThread, std::default_delete&lt;top1::TapeDiskThread&gt; &gt;" />
  </field>
  <field access="protected" id="top1::TapeBuffer::playPoint" name="playPoint">
    <brief>The current position on the tape, counted in frames from the beginning</brief>
    <type name="std::atomic_uint" />
  </field>
  <field access="protected" id="top1::TapeBuffer::readData" name="readData">
    <type name="std::_V2::condition_variable_any" />
  </field>
  <field access="protected" id="top1::TapeBuffer::newCuts" name="newCuts">
    <type name="std::atomic_bool" />
  </field>
  <field access="protected" id="top1::TapeBuffer::clipboard" name="clipboard">
    <type name="struct (anonymous struct at /home/travis/build/topisani/TOP-1/src/util/tapebuffer.hpp:96:5)" ref="top1::TapeBuffer#top1::TapeBuffer::(anonymous::1)" />
  </field>
  <method abstract="yes" access="protected" id="top1::TapeBuffer::movePlaypointAbs" name="movePlaypointAbs">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::TapeBuffer::movePlaypointAbs::pos" name="pos">
      <type builtin="yes" name="int" />
    </argument>
  </method>
  <method abstract="yes" access="protected" id="top1::TapeBuffer::movePlaypointRel" name="movePlaypointRel">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::TapeBuffer::movePlaypointRel::time" name="time">
      <type builtin="yes" name="int" />
    </argument>
  </method>
  <method abstract="yes" access="protected" id="top1::TapeBuffer::threadRoutine" name="threadRoutine">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
</class>
