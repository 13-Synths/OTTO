<?xml version='1.0' encoding='utf-8'?>
<class abstract="true" id="top1::SoundFile" name="SoundFile" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <base access="public">
    <type name="ByteFile" ref="top1::ByteFile#top1::ByteFile" />
    <brief>TODO: Documentation</brief>
  </base>
  <subclass access="public" name="TapeFile" ref="top1::TapeFile#top1::TapeFile" />
  <methodtemplate id="top1::SoundFile::read_samples" name="read_samples">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::SoundFile::read_samples::" name="">
      <type name="OutIter" />
    </argument>
    <argument id="top1::SoundFile::read_samples::" name="">
      <type name="OutIter" />
    </argument>
    <templatetypeparameter id="top1::SoundFile::read_samples::OutIter" name="OutIter" />
    <templatetypeparameter id="top1::SoundFile::read_samples" />
    <templatetypeparameter id="top1::SoundFile::read_samples::OutIter" name="OutIter" />
    <templatetypeparameter id="top1::SoundFile::read_samples" />
  </methodtemplate>
  <methodtemplate id="top1::SoundFile::read_samples" name="read_samples">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::SoundFile::read_samples::" name="">
      <type name="OutIter &amp;&amp;" />
    </argument>
    <argument id="top1::SoundFile::read_samples::" name="">
      <type builtin="yes" name="int" />
    </argument>
    <templatetypeparameter id="top1::SoundFile::read_samples::OutIter" name="OutIter" />
    <templatetypeparameter id="top1::SoundFile::read_samples" />
    <templatetypeparameter id="top1::SoundFile::read_samples::OutIter" name="OutIter" />
    <templatetypeparameter id="top1::SoundFile::read_samples" />
  </methodtemplate>
  <variable id="top1::SoundFile::sample_size" name="sample_size">
    <type name="std::size_t" qualifier=" const" />
  </variable>
  <methodtemplate id="top1::SoundFile::write_samples" name="write_samples">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::SoundFile::write_samples::" name="">
      <type name="InIter" />
    </argument>
    <argument id="top1::SoundFile::write_samples::" name="">
      <type name="InIter" />
    </argument>
    <templatetypeparameter id="top1::SoundFile::write_samples::InIter" name="InIter" />
    <templatetypeparameter id="top1::SoundFile::write_samples" />
    <templatetypeparameter id="top1::SoundFile::write_samples::InIter" name="InIter" />
    <templatetypeparameter id="top1::SoundFile::write_samples" />
  </methodtemplate>
  <methodtemplate id="top1::SoundFile::write_samples" name="write_samples">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::SoundFile::write_samples::" name="">
      <type name="InIter &amp;&amp;" />
    </argument>
    <argument id="top1::SoundFile::write_samples::" name="">
      <type builtin="yes" name="int" />
    </argument>
    <templatetypeparameter id="top1::SoundFile::write_samples::InIter" name="InIter" />
    <templatetypeparameter id="top1::SoundFile::write_samples" />
    <templatetypeparameter id="top1::SoundFile::write_samples::InIter" name="InIter" />
    <templatetypeparameter id="top1::SoundFile::write_samples" />
  </methodtemplate>
  <struct name="Info" ref="top1::SoundFile::Info#top1::SoundFile::Info" />
  <enum class="yes" id="top1::SoundFile::Error" name="Error">
    <enumvalue id="top1::SoundFile::Error::UnrecognizedFileType" name="UnrecognizedFileType" value="0" />
  </enum>
  <field id="top1::SoundFile::info" name="info">
    <type name="Info" ref="top1::SoundFile::Info#top1::SoundFile::Info" />
  </field>
  <constructor abstract="yes" id="top1::SoundFile::SoundFile" name="SoundFile" />
  <method abstract="yes" id="top1::SoundFile::length" name="length">
    <undocumented-return />
    <return>
      <type name="Position" />
    </return>
  </method>
  <method abstract="yes" id="top1::SoundFile::position" name="position" override="yes">
    <undocumented-return />
    <return>
      <type name="Position" />
    </return>
    <override name="ByteFile::position" ref="top1::ByteFile#top1::ByteFile::position" />
  </method>
  <method abstract="yes" id="top1::SoundFile::read_file" name="read_file" override="yes" virtual="yes">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <override name="ByteFile::read_file" ref="top1::ByteFile#top1::ByteFile::read_file" />
  </method>
  <method abstract="yes" id="top1::SoundFile::seek" name="seek" override="yes">
    <undocumented-return />
    <return>
      <type name="Position" />
    </return>
    <argument id="top1::SoundFile::seek::" name="">
      <type name="Position" />
    </argument>
    <override name="ByteFile::seek" ref="top1::ByteFile#top1::ByteFile::seek" />
  </method>
  <method abstract="yes" id="top1::SoundFile::write_file" name="write_file" override="yes" virtual="yes">
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <override name="ByteFile::write_file" ref="top1::ByteFile#top1::ByteFile::write_file" />
  </method>
  <field access="protected" id="top1::SoundFile::audioOffset" name="audioOffset">
    <type name="ByteFile::Position" />
  </field>
  <method access="protected" id="top1::SoundFile::add_custom_chunks" name="add_custom_chunks" virtual="yes">
    <brief>When extending <ref ref="top1::SoundFile#top1::SoundFile::SoundFile">top1::SoundFile::SoundFile</ref>, override this function.
</brief>
    <doc>It should push back any custom metadata chunks to `v`</doc>
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::SoundFile::add_custom_chunks::v" name="v">
      <type name="std::vector&lt;std::unique_ptr&lt;top1::ByteFile::Chunk, std::default_delete&lt;top1::ByteFile::Chunk&gt; &gt;, std::allocator&lt;std::unique_ptr&lt;top1::ByteFile::Chunk, std::default_delete&lt;top1::ByteFile::Chunk&gt; &gt; &gt; &gt;" qualifier=" &amp;" />
    </argument>
  </method>
  <method access="protected" id="top1::SoundFile::bytes_to_sample" name="bytes_to_sample">
    <undocumented-return />
    <return>
      <type name="Sample" />
    </return>
    <argument id="top1::SoundFile::bytes_to_sample::bytes" name="bytes">
      <type name="bytes&lt;4&gt;" />
    </argument>
  </method>
  <method access="protected" id="top1::SoundFile::replace_custom_chunk" name="replace_custom_chunk" virtual="yes">
    <brief>When extending <ref ref="top1::SoundFile#top1::SoundFile::SoundFile">top1::SoundFile::SoundFile</ref>, override this function.
</brief>
    <doc>It should check the id of `ptr`, and if it matches,
swap it with an instance of the correct class.
If the chunk is unknown, leave it alone. After this,
<ref ref="top1::ByteFile::Chunk#top1::ByteFile::Chunk::read">top1::ByteFile::Chunk::read</ref> will be invoked on `ptr`.</doc>
    <undocumented-return />
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="top1::SoundFile::replace_custom_chunk::ptr" name="ptr">
      <type name="std::unique_ptr&lt;top1::ByteFile::Chunk, std::default_delete&lt;top1::ByteFile::Chunk&gt; &gt;" qualifier=" &amp;" />
    </argument>
  </method>
  <method access="protected" id="top1::SoundFile::sample_to_bytes" name="sample_to_bytes">
    <undocumented-return />
    <return>
      <type name="bytes&lt;4&gt;" />
    </return>
    <argument id="top1::SoundFile::sample_to_bytes::sample" name="sample">
      <type name="Sample" />
    </argument>
  </method>
</class>
